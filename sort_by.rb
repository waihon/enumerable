# sort_by { |obj| block } → array
# sort_by → an_enumerator
# 
# Sorts enum using a set of keys generated by mapping the values in enum 
# through the given block.
#
# If no block is given, an enumerator is returned instead.
#
# As of Ruby 1.8, the method Enumerable#sort_by implements a built-in 
# Schwartzian Transform, useful when key computation or comparison is expensive.

require 'pp'
require 'benchmark'

pp %w(apple pear mangosteen fig).sort_by { |word| word.length }  
#=> ["fig", "pear", "apple", "mangosteen"]

# The current implementation of sort_by generates an array of tuples containing 
# the original collection element and the mapped value. This makes sort_by 
# fairly expensive when the keysets are simple.
array = (1..100000).map { rand(100000) }
Benchmark.bm(10) do |b|
  b.report("Sort") { array.sort }
  b.report("Sort by") { array.sort_by { |a| a } }
end
#=>                 user     system      total        real
#   Sort         0.020000   0.000000   0.020000 (  0.023728)
#   Sort by      0.120000   0.000000   0.120000 (  0.130552)

files = Dir["*"]
Benchmark.bm(50) do |b|
  # This sort is inefficient: it generates 2 new File objects during
  # every comparison.
  b.report("Sort - mtime") do
    files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
  end
  
  # A slightly better technique is to use the Kernel#test method to
  # generate the modification times directly.
  b.report("Sort - Kernel#test") do
    files.sort { |a, b| test(?M, a) <=> test(?M, b) }
  end

  # This still generates many unnecessary Time objects. A more efficient
  # technique is to cache the sort keys (modification times in this case)
  # before the sort. Perl users often call this approach a Schwartzian
  # Transform, after Randal Schwartz. We construct a temporary array,
  # where each element is an array containing our sort key along with the
  # filename. We sort this array, and then extract the filename from the 
  # result.
  b.report("Sort - Kernet#test & Schwartzian") do
    files.map { |f| 
      [test(?M, f), f] 
    }.sort.map { |f| f[1] }
  end

  # This is exactly what sort_by does internally
  b.report ("Sort by") do
    files.sort_by { |f| test(?M, f) }
  end
end
#=>                                          user     system      total        real
#  Sort - mtime                          0.010000   0.000000   0.010000 (  0.003985)
#  Sort - Kernel#test                    0.000000   0.000000   0.000000 (  0.001301)
#  Sort - Kernet#test & Schwartzian      0.000000   0.000000   0.000000 (  0.000271)
#  Sort by                               0.000000   0.000000   0.000000 (  0.000214)